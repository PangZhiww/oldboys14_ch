# 构造犯法   申请一个空间
# 析构方法   释放一个空间之前执行的
# 某对象借用了操作系统的资源, 还要通过析构方法归还回去: 文件资源   网络资源

# 垃圾回收机制
# class A:
#     def __del__(self):  # 析构方法  del A的对象, 会自动触发这个方法
#         print("执行我了!!!")
# a = A()
# del a   # 对象删除  先执行__del__, 然后再删除对象
# print(a)

# class File:
#     # 处理文件
#     def __init__(self,file_path):
#         self.f = open(file_path)
#         self.name = "alex"
#
#     def read(self):
#         self.f.read(1024)
#
#     def __del__(self):  # 是去归还/释放一些在创建对象的时候借用(系统上)的一些资源
#         # 什么时候执行?
#             # del 对象的时候   程序员触发的
#             # Python解释器的垃圾回收机制, 回收这个对象所占的内存的时候    Python自动触发的
#         self.f.close()  # 在Python解释器归还资源之前, 先把借用操作系统的文件资源归还
#
# f = File("文件名")
# f.read()
# 不管是主动还是被动, 这个f对象总会被清理掉的, 被清理掉就会触发__del__方法, 触发这个方法就会归还操作系统的文件资源


# python解释器在内部就能搞定的事儿
# 申请一块空间, 操作系统分配给你的
# 在这一块儿空间之内的所有事儿, 归你的Python解释器来管理

# f = open("wenjian") # python --> 操作系统 --> 磁盘里的文件 --> 文件操作符(文件句柄)
# f.close()   # 给操作系统指令, 关闭系统, 归还系统的资源
# del f   # 不能关闭系统的, 仅仅是Python内部的